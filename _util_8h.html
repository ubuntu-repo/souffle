<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>souffle: Util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">souffle
   &#160;<span id="projectnumber">1.5.1-568-gdf7f668</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Util.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="_ram_types_8h_source.html">RamTypes.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;atomic&gt;</code><br />
<code>#include &lt;chrono&gt;</code><br />
<code>#include &lt;condition_variable&gt;</code><br />
<code>#include &lt;cstdlib&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;mutex&gt;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cctype&gt;</code><br />
<code>#include &lt;cerrno&gt;</code><br />
<code>#include &lt;climits&gt;</code><br />
<code>#include &lt;cstdarg&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;libgen.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Util.h:</div>
<div class="dyncontent">
<div class="center"><img src="_util_8h__incl.png" border="0" usemap="#_util_8h" alt=""/></div>
<map name="_util_8h" id="_util_8h">
<area shape="rect" id="node2" href="_ram_types_8h.html" title="RamTypes.h" alt="" coords="25,80,124,107"/>
</map>
</div>
</div>
<p><a href="_util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_cache_access_counter.html">souffle::CacheAccessCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to keep track of cache hits/misses.  <a href="classsouffle_1_1_cache_access_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1comp__deref.html">souffle::comp_deref&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor class supporting the values pointers are pointing to.  <a href="structsouffle_1_1comp__deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1deref.html">souffle::deref&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor dereferencing a given type.  <a href="structsouffle_1_1deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1deref__less.html">souffle::deref_less&lt; T, C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor comparing the dereferenced value of a pointer type utilizing a given comparator.  <a href="structsouffle_1_1deref__less.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1id.html">souffle::id&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor representing the identity function for a generic type T.  <a href="structsouffle_1_1id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1is__printable.html">souffle::detail::is_printable&lt; T, filter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait to check whether a given type is printable.  <a href="structsouffle_1_1detail_1_1is__printable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1detail_1_1joined__sequence.html">souffle::detail::joined_sequence&lt; Iter, Printer &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A auxiliary class to be returned by the join function aggregating the information required to print a list of elements as well as the implementation of the printing itself.  <a href="classsouffle_1_1detail_1_1joined__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1lambda__traits.html">souffle::lambda_traits&lt; Lambda &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait enabling the deduction of type properties of lambdas.  <a href="structsouffle_1_1lambda__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper.html">souffle::detail::lambda_traits_helper&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper_3_01_r_07_a0_08_4.html">souffle::detail::lambda_traits_helper&lt; R(A0)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper_3_01_r_07_a0_00_01_a1_08_4.html">souffle::detail::lambda_traits_helper&lt; R(A0, A1)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper_3_01_r_07_args_8_8_8_08_4.html">souffle::detail::lambda_traits_helper&lt; R(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01_01_4.html">souffle::detail::lambda_traits_helper&lt; R(C::*)(Args...) const  &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1lambda__traits__helper_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_4.html">souffle::detail::lambda_traits_helper&lt; R(C::*)(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_l_r_u_cache.html">souffle::LRUCache&lt; T, size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Least-Recently-Used cache for arbitrary element types.  <a href="classsouffle_1_1_l_r_u_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_l_r_u_cache_3_01_t_00_010_01_4.html">souffle::LRUCache&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_l_r_u_cache_3_01_t_00_011_01_4.html">souffle::LRUCache&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1member__fun.html">souffle::member_fun&lt; Class, R, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct wrapping a object and an associated member function pointer into a callable object.  <a href="structsouffle_1_1member__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1multiplying__printer.html">souffle::detail::multiplying_printer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class required for the implementation of the times function.  <a href="structsouffle_1_1detail_1_1multiplying__printer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1_null_stream_1_1_null_buffer.html">souffle::NullStream::NullBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_null_stream.html">souffle::NullStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream ignoring everything written to it.  <a href="classsouffle_1_1_null_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1detail_1_1print.html">souffle::detail::print&lt; Extractor &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic element printer.  <a href="structsouffle_1_1detail_1_1print.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1print__deref.html">souffle::print_deref&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor printing elements after dereferencing it.  <a href="structsouffle_1_1print__deref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsouffle_1_1range.html">souffle::range&lt; Iter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class enabling representation of ranges by pairing two iterator instances marking lower and upper boundaries.  <a href="structsouffle_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1shared__mutex.html">souffle::shared_mutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsouffle_1_1_split_stream.html">souffle::SplitStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream copying its input to multiple output streams.  <a href="classsouffle_1_1_split_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesouffle"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html">souffle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesouffle_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle_1_1detail.html">souffle::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestd.html">std</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a80fa0d26915405815f4a95751cafa736"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_util_8h.html#a80fa0d26915405815f4a95751cafa736">stord</a>(a)&#160;&#160;&#160;std::stoi(a)</td></tr>
<tr class="memdesc:a80fa0d26915405815f4a95751cafa736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to a number.  <a href="#a80fa0d26915405815f4a95751cafa736">More...</a><br /></td></tr>
<tr class="separator:a80fa0d26915405815f4a95751cafa736"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9eb29a1677ffbe44fe8663f881213f0e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9eb29a1677ffbe44fe8663f881213f0e">souffle::time_point</a> = std::chrono::high_resolution_clock::time_point</td></tr>
<tr class="separator:a9eb29a1677ffbe44fe8663f881213f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8a2c294e3ff514cd4ca29b466ff3cab3">souffle::absPath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++-style realpath.  <a href="namespacesouffle.html#a8a2c294e3ff514cd4ca29b466ff3cab3">More...</a><br /></td></tr>
<tr class="separator:a8a2c294e3ff514cd4ca29b466ff3cab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b5f9eb9ec09c40e558b242e75de872"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a14b5f9eb9ec09c40e558b242e75de872"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">souffle::all_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:a14b5f9eb9ec09c40e558b242e75de872"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether all elements within a container satisfy a certain predicate.  <a href="namespacesouffle.html#a14b5f9eb9ec09c40e558b242e75de872">More...</a><br /></td></tr>
<tr class="separator:a14b5f9eb9ec09c40e558b242e75de872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">souffle::any_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:a34f8eecb81c090fca9e58d3357b63ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether any elements within a container satisfy a certain predicate.  <a href="namespacesouffle.html#a34f8eecb81c090fca9e58d3357b63ed9">More...</a><br /></td></tr>
<tr class="separator:a34f8eecb81c090fca9e58d3357b63ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbc2262a6164b62766f6fcb67f12ae4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9fbc2262a6164b62766f6fcb67f12ae4">souffle::baseName</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:a9fbc2262a6164b62766f6fcb67f12ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3295dd83a588d612cf777e600beac4a"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:af3295dd83a588d612cf777e600beac4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af3295dd83a588d612cf777e600beac4a">souffle::contains</a> (const C &amp;container, const typename C::value_type &amp;element)</td></tr>
<tr class="memdesc:af3295dd83a588d612cf777e600beac4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility to check generically whether a given element is contained in a given container.  <a href="namespacesouffle.html#af3295dd83a588d612cf777e600beac4a">More...</a><br /></td></tr>
<tr class="separator:af3295dd83a588d612cf777e600beac4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e10d44624c80609e5c09b131ecf3fb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">souffle::dirName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a72e10d44624c80609e5c09b131ecf3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++-style dirname.  <a href="namespacesouffle.html#a72e10d44624c80609e5c09b131ecf3fb">More...</a><br /></td></tr>
<tr class="separator:a72e10d44624c80609e5c09b131ecf3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba27d2caf5a777268d89eaf5cbfed2a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8ba27d2caf5a777268d89eaf5cbfed2a">souffle::duration_in_ns</a> (const time_point &amp;start, const time_point &amp;end)</td></tr>
<tr class="separator:a8ba27d2caf5a777268d89eaf5cbfed2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3be713865e2b9922aa0eac1fb629041"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af3be713865e2b9922aa0eac1fb629041">souffle::duration_in_us</a> (const time_point &amp;start, const time_point &amp;end)</td></tr>
<tr class="separator:af3be713865e2b9922aa0eac1fb629041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e84ddff3bc168499fa141d3a3998494"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e84ddff3bc168499fa141d3a3998494">souffle::endsWith</a> (const std::string &amp;value, const std::string &amp;ending)</td></tr>
<tr class="memdesc:a6e84ddff3bc168499fa141d3a3998494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given value string ends with the given end string.  <a href="namespacesouffle.html#a6e84ddff3bc168499fa141d3a3998494">More...</a><br /></td></tr>
<tr class="separator:a6e84ddff3bc168499fa141d3a3998494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0083e5ad86e88ff726ea4e3c7ef23c1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Comp  = std::equal_to&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ab0083e5ad86e88ff726ea4e3c7ef23c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab0083e5ad86e88ff726ea4e3c7ef23c1">souffle::equal</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const Comp &amp;comp=Comp())</td></tr>
<tr class="memdesc:ab0083e5ad86e88ff726ea4e3c7ef23c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two vectors are equal (same vector of elements).  <a href="namespacesouffle.html#ab0083e5ad86e88ff726ea4e3c7ef23c1">More...</a><br /></td></tr>
<tr class="separator:ab0083e5ad86e88ff726ea4e3c7ef23c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71900d5ac92d70a4132fff4e280dd1cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Comp  = std::equal_to&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a71900d5ac92d70a4132fff4e280dd1cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">souffle::equal</a> (const std::set&lt; T &gt; &amp;a, const std::set&lt; T &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const Comp &amp;comp=Comp())</td></tr>
<tr class="memdesc:a71900d5ac92d70a4132fff4e280dd1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two sets are equal (same set of elements).  <a href="namespacesouffle.html#a71900d5ac92d70a4132fff4e280dd1cd">More...</a><br /></td></tr>
<tr class="separator:a71900d5ac92d70a4132fff4e280dd1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab097fb451e787a08a185a449bacde2db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab097fb451e787a08a185a449bacde2db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab097fb451e787a08a185a449bacde2db">souffle::equal_ptr</a> (const T *a, const T *<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:ab097fb451e787a08a185a449bacde2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent.  <a href="namespacesouffle.html#ab097fb451e787a08a185a449bacde2db">More...</a><br /></td></tr>
<tr class="separator:ab097fb451e787a08a185a449bacde2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9b13dfdf28e89958f7adeaa43abbe34f">souffle::equal_ptr</a> (const std::unique_ptr&lt; T &gt; &amp;a, const std::unique_ptr&lt; T &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values referenced by a pointer where the case where both pointers are null is also considered equivalent.  <a href="namespacesouffle.html#a9b13dfdf28e89958f7adeaa43abbe34f">More...</a><br /></td></tr>
<tr class="separator:a9b13dfdf28e89958f7adeaa43abbe34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961b0d79be71a35f0b60aeedf212fe4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a961b0d79be71a35f0b60aeedf212fe4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a961b0d79be71a35f0b60aeedf212fe4a">souffle::equal_targets</a> (const std::vector&lt; T * &gt; &amp;a, const std::vector&lt; T * &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a961b0d79be71a35f0b60aeedf212fe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two vector of pointers are referencing to equivalent targets.  <a href="namespacesouffle.html#a961b0d79be71a35f0b60aeedf212fe4a">More...</a><br /></td></tr>
<tr class="separator:a961b0d79be71a35f0b60aeedf212fe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae042a1a59dfe209421a92154e83b3145"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae042a1a59dfe209421a92154e83b3145"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ae042a1a59dfe209421a92154e83b3145">souffle::equal_targets</a> (const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;a, const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:ae042a1a59dfe209421a92154e83b3145"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two vector of pointers are referencing to equivalent targets.  <a href="namespacesouffle.html#ae042a1a59dfe209421a92154e83b3145">More...</a><br /></td></tr>
<tr class="separator:ae042a1a59dfe209421a92154e83b3145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9c6f3c99122a5e04e14bd3d26f9e21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef9c6f3c99122a5e04e14bd3d26f9e21"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aef9c6f3c99122a5e04e14bd3d26f9e21">souffle::equal_targets</a> (const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;a, const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:aef9c6f3c99122a5e04e14bd3d26f9e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two vector of pointers are referencing to equivalent targets.  <a href="namespacesouffle.html#aef9c6f3c99122a5e04e14bd3d26f9e21">More...</a><br /></td></tr>
<tr class="separator:aef9c6f3c99122a5e04e14bd3d26f9e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e426c93033a166915ea2990c513a4fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e426c93033a166915ea2990c513a4fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e426c93033a166915ea2990c513a4fa">souffle::equal_targets</a> (const std::set&lt; T * &gt; &amp;a, const std::set&lt; T * &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a6e426c93033a166915ea2990c513a4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two set of pointers are referencing to equivalent targets.  <a href="namespacesouffle.html#a6e426c93033a166915ea2990c513a4fa">More...</a><br /></td></tr>
<tr class="separator:a6e426c93033a166915ea2990c513a4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806a1898ee38dcc89c3a7d24a18e9fcb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a806a1898ee38dcc89c3a7d24a18e9fcb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a806a1898ee38dcc89c3a7d24a18e9fcb">souffle::equal_targets</a> (const std::set&lt; std::unique_ptr&lt; T &gt;&gt; &amp;a, const std::set&lt; std::unique_ptr&lt; T &gt;&gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a806a1898ee38dcc89c3a7d24a18e9fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two set of pointers are referencing to equivalent targets.  <a href="namespacesouffle.html#a806a1898ee38dcc89c3a7d24a18e9fcb">More...</a><br /></td></tr>
<tr class="separator:a806a1898ee38dcc89c3a7d24a18e9fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbdbf02eb7f38788faa2880c7f600d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fbdbf02eb7f38788faa2880c7f600d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7fbdbf02eb7f38788faa2880c7f600d7">souffle::equal_targets</a> (const std::set&lt; std::shared_ptr&lt; T &gt;&gt; &amp;a, const std::set&lt; std::shared_ptr&lt; T &gt;&gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:a7fbdbf02eb7f38788faa2880c7f600d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function testing whether two set of pointers are referencing to equivalent targets.  <a href="namespacesouffle.html#a7fbdbf02eb7f38788faa2880c7f600d7">More...</a><br /></td></tr>
<tr class="separator:a7fbdbf02eb7f38788faa2880c7f600d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fa4170c4094bc943de6fa5acb5796e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">souffle::existDir</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a79fa4170c4094bc943de6fa5acb5796e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a directory exists in the file system.  <a href="namespacesouffle.html#a79fa4170c4094bc943de6fa5acb5796e">More...</a><br /></td></tr>
<tr class="separator:a79fa4170c4094bc943de6fa5acb5796e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69107e934a60222580ee8ba6882dc3d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">souffle::existFile</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a69107e934a60222580ee8ba6882dc3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a file exists in the file system.  <a href="namespacesouffle.html#a69107e934a60222580ee8ba6882dc3d3">More...</a><br /></td></tr>
<tr class="separator:a69107e934a60222580ee8ba6882dc3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3419b4e4df09a580063d2f078a3774"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a8e3419b4e4df09a580063d2f078a3774">souffle::fileExtension</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:a8e3419b4e4df09a580063d2f078a3774"><td class="mdescLeft">&#160;</td><td class="mdescRight">File extension, with all else removed.  <a href="namespacesouffle.html#a8e3419b4e4df09a580063d2f078a3774">More...</a><br /></td></tr>
<tr class="separator:a8e3419b4e4df09a580063d2f078a3774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af944f0c474df29e5c8e45e4b7df60be5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af944f0c474df29e5c8e45e4b7df60be5">souffle::findTool</a> (const std::string &amp;tool, const std::string &amp;<a class="el" href="_reader_8h.html#a4ce824b383e7379148b61ee135baac5a">base</a>, const std::string &amp;path)</td></tr>
<tr class="separator:af944f0c474df29e5c8e45e4b7df60be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e8debde5608979e041dd30e044612a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a">souffle::identifier</a> (std::string id)</td></tr>
<tr class="memdesc:ad0e8debde5608979e041dd30e044612a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid C++ identifier, note that this does not ensure the uniqueness of identifiers returned.  <a href="namespacesouffle.html#ad0e8debde5608979e041dd30e044612a">More...</a><br /></td></tr>
<tr class="separator:ad0e8debde5608979e041dd30e044612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64753e143a37bb9414121fc75987cb14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">souffle::isExecutable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a64753e143a37bb9414121fc75987cb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given file exists and it is an executable.  <a href="namespacesouffle.html#a64753e143a37bb9414121fc75987cb14">More...</a><br /></td></tr>
<tr class="separator:a64753e143a37bb9414121fc75987cb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91f27920d30575842a1fdfd0d53f348"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa91f27920d30575842a1fdfd0d53f348">souffle::isHintsProfilingEnabled</a> ()</td></tr>
<tr class="memdesc:aa91f27920d30575842a1fdfd0d53f348"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to determine whether hints-profiling is enabled or disabled;.  <a href="namespacesouffle.html#aa91f27920d30575842a1fdfd0d53f348">More...</a><br /></td></tr>
<tr class="separator:aa91f27920d30575842a1fdfd0d53f348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56909036ae0514924e306d0a1a180837"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837">souffle::isNumber</a> (const char *<a class="el" href="json11_8h.html#a6f94ddd542b6584a9155dca6dff07fdc">str</a>)</td></tr>
<tr class="memdesc:a56909036ae0514924e306d0a1a180837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a string is a sequence of numbers.  <a href="namespacesouffle.html#a56909036ae0514924e306d0a1a180837">More...</a><br /></td></tr>
<tr class="separator:a56909036ae0514924e306d0a1a180837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d08224020b450cc75146bcec8a281bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7d08224020b450cc75146bcec8a281bb">souffle::isTransactionProfilingEnabled</a> ()</td></tr>
<tr class="memdesc:a7d08224020b450cc75146bcec8a281bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to determine whether transaction-profiling is enabled or disabled;.  <a href="namespacesouffle.html#a7d08224020b450cc75146bcec8a281bb">More...</a><br /></td></tr>
<tr class="separator:a7d08224020b450cc75146bcec8a281bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4e3f19879707216a2758b03f4e2deb"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Printer &gt; </td></tr>
<tr class="memitem:abe4e3f19879707216a2758b03f4e2deb"><td class="memTemplItemLeft" align="right" valign="top">detail::joined_sequence&lt; Iter, Printer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">souffle::join</a> (const Iter &amp;a, const Iter &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const std::string &amp;sep, const Printer &amp;<a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:abe4e3f19879707216a2758b03f4e2deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator.  <a href="namespacesouffle.html#abe4e3f19879707216a2758b03f4e2deb">More...</a><br /></td></tr>
<tr class="separator:abe4e3f19879707216a2758b03f4e2deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename T  = typename Iter::value_type&gt; </td></tr>
<tr class="memitem:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memTemplItemLeft" align="right" valign="top">detail::joined_sequence&lt; Iter, detail::print&lt; id&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2ff8ab73e5403aebf8bc9e0cd8a17655">souffle::join</a> (const Iter &amp;a, const Iter &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>, const std::string &amp;sep=&quot;,&quot;)</td></tr>
<tr class="memdesc:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing sequences of elements interspersed by a given separator.  <a href="namespacesouffle.html#a2ff8ab73e5403aebf8bc9e0cd8a17655">More...</a><br /></td></tr>
<tr class="separator:a2ff8ab73e5403aebf8bc9e0cd8a17655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5411f3812147edc8be88140d80308bd"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Printer , typename Iter  = typename Container::const_iterator&gt; </td></tr>
<tr class="memitem:af5411f3812147edc8be88140d80308bd"><td class="memTemplItemLeft" align="right" valign="top">detail::joined_sequence&lt; Iter, Printer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af5411f3812147edc8be88140d80308bd">souffle::join</a> (const Container &amp;c, const std::string &amp;sep, const Printer &amp;<a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:af5411f3812147edc8be88140d80308bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator.  <a href="namespacesouffle.html#af5411f3812147edc8be88140d80308bd">More...</a><br /></td></tr>
<tr class="separator:af5411f3812147edc8be88140d80308bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Iter  = typename Container::const_iterator, typename T  = typename Iter::value_type&gt; </td></tr>
<tr class="memitem:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memTemplItemLeft" align="right" valign="top">detail::joined_sequence&lt; Iter, detail::print&lt; id&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">souffle::join</a> (const Container &amp;c, const std::string &amp;sep=&quot;,&quot;)</td></tr>
<tr class="memdesc:af2f126a2c7d2ee710ec8600b2af64da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object to be forwarded to some output stream for printing the content of containers interspersed by a given separator.  <a href="namespacesouffle.html#af2f126a2c7d2ee710ec8600b2af64da3">More...</a><br /></td></tr>
<tr class="separator:af2f126a2c7d2ee710ec8600b2af64da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea8a37cc1681f657054f3b30af55003"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:acea8a37cc1681f657054f3b30af55003"><td class="memTemplItemLeft" align="right" valign="top">range&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">souffle::make_range</a> (const Iter &amp;a, const Iter &amp;<a class="el" href="html_js_chartist_min_8h.html#a4cb409b8fe88d81ab7faab0d1bbb878d">b</a>)</td></tr>
<tr class="memdesc:acea8a37cc1681f657054f3b30af55003"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the construction of ranges without explicitly specifying the iterator type.  <a href="namespacesouffle.html#acea8a37cc1681f657054f3b30af55003">More...</a><br /></td></tr>
<tr class="separator:acea8a37cc1681f657054f3b30af55003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b4d0d4c0df3b810331af0a4ec93d23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a10b4d0d4c0df3b810331af0a4ec93d23">souffle::maxRetries</a> ()</td></tr>
<tr class="memdesc:a10b4d0d4c0df3b810331af0a4ec93d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to set the maximum number of retries for a transaction if Intel RTM is enabled (default 15);.  <a href="namespacesouffle.html#a10b4d0d4c0df3b810331af0a4ec93d23">More...</a><br /></td></tr>
<tr class="separator:a10b4d0d4c0df3b810331af0a4ec93d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7603fe80c7e2681fa81a67870058f60c"><td class="memTemplParams" colspan="2">template&lt;typename C , typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a7603fe80c7e2681fa81a67870058f60c"><td class="memTemplItemLeft" align="right" valign="top">member_fun&lt; C, R, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a7603fe80c7e2681fa81a67870058f60c">souffle::mfun</a> (C &amp;obj, R(C::*f)(Args...))</td></tr>
<tr class="memdesc:a7603fe80c7e2681fa81a67870058f60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps an object and matching member function pointer into a callable object.  <a href="namespacesouffle.html#a7603fe80c7e2681fa81a67870058f60c">More...</a><br /></td></tr>
<tr class="separator:a7603fe80c7e2681fa81a67870058f60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f038770077ca498a606a43458b26e6"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:ac2f038770077ca498a606a43458b26e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ac2f038770077ca498a606a43458b26e6">souffle::movePtrVector</a> (std::vector&lt; std::unique_ptr&lt; X &gt;&gt; &amp;source, std::vector&lt; std::unique_ptr&lt; Y &gt;&gt; &amp;destination)</td></tr>
<tr class="memdesc:ac2f038770077ca498a606a43458b26e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function that moves a vector of unique pointers from a source to a destination.  <a href="namespacesouffle.html#ac2f038770077ca498a606a43458b26e6">More...</a><br /></td></tr>
<tr class="separator:ac2f038770077ca498a606a43458b26e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#af4ec690ba482fd3a9692b5e31f6ad347">souffle::none_of</a> (const Container &amp;c, UnaryPredicate <a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:af4ec690ba482fd3a9692b5e31f6ad347"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic test checking whether all elements within a container satisfy a certain predicate.  <a href="namespacesouffle.html#af4ec690ba482fd3a9692b5e31f6ad347">More...</a><br /></td></tr>
<tr class="separator:af4ec690ba482fd3a9692b5e31f6ad347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c65551944c7ecf6f44ec851b49bdbb0"><td class="memItemLeft" align="right" valign="top">time_point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a1c65551944c7ecf6f44ec851b49bdbb0">souffle::now</a> ()</td></tr>
<tr class="separator:a1c65551944c7ecf6f44ec851b49bdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6007ce16b81c3fdec0c880158b23724f"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a6007ce16b81c3fdec0c880158b23724f"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#a6007ce16b81c3fdec0c880158b23724f">std::operator&lt;&lt;</a> (ostream &amp;out, const pair&lt; A, B &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a0e2839cf85d4f50ed7cdcc6c1b3adf83">p</a>)</td></tr>
<tr class="memdesc:a6007ce16b81c3fdec0c880158b23724f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduces support for printing pairs as long as their components can be printed.  <a href="namespacestd.html#a6007ce16b81c3fdec0c880158b23724f">More...</a><br /></td></tr>
<tr class="separator:a6007ce16b81c3fdec0c880158b23724f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d19261c7952cc862dfc6a3772c0f9af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a3d19261c7952cc862dfc6a3772c0f9af"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#a3d19261c7952cc862dfc6a3772c0f9af">std::operator&lt;&lt;</a> (ostream &amp;out, const vector&lt; T, A &gt; &amp;v)</td></tr>
<tr class="memdesc:a3d19261c7952cc862dfc6a3772c0f9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the generic printing of vectors assuming their element types are printable.  <a href="namespacestd.html#a3d19261c7952cc862dfc6a3772c0f9af">More...</a><br /></td></tr>
<tr class="separator:a3d19261c7952cc862dfc6a3772c0f9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f5c175f65d86392baae03362443f7b"><td class="memTemplParams" colspan="2">template&lt;typename K , typename C , typename A &gt; </td></tr>
<tr class="memitem:a24f5c175f65d86392baae03362443f7b"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#a24f5c175f65d86392baae03362443f7b">std::operator&lt;&lt;</a> (ostream &amp;out, const set&lt; K, C, A &gt; &amp;s)</td></tr>
<tr class="memdesc:a24f5c175f65d86392baae03362443f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the generic printing of sets assuming their element types are printable.  <a href="namespacestd.html#a24f5c175f65d86392baae03362443f7b">More...</a><br /></td></tr>
<tr class="separator:a24f5c175f65d86392baae03362443f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02df97e37b3af7690816a8097e6f4740"><td class="memTemplParams" colspan="2">template&lt;typename K , typename T , typename C , typename A &gt; </td></tr>
<tr class="memitem:a02df97e37b3af7690816a8097e6f4740"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestd.html#a02df97e37b3af7690816a8097e6f4740">std::operator&lt;&lt;</a> (ostream &amp;out, const map&lt; K, T, C, A &gt; &amp;<a class="el" href="html_js_chartist_min_8h.html#a9e77e016b2928d7dcb493b89a0c9dc32">m</a>)</td></tr>
<tr class="memdesc:a02df97e37b3af7690816a8097e6f4740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the generic printing of maps assuming their element types are printable.  <a href="namespacestd.html#a02df97e37b3af7690816a8097e6f4740">More...</a><br /></td></tr>
<tr class="separator:a02df97e37b3af7690816a8097e6f4740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfb7f5671f38232db9a50606d07fe04"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned size&gt; </td></tr>
<tr class="memitem:a9dfb7f5671f38232db9a50606d07fe04"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9dfb7f5671f38232db9a50606d07fe04">souffle::operator&lt;&lt;</a> (std::ostream &amp;out, const LRUCache&lt; T, size &gt; &amp;cache)</td></tr>
<tr class="separator:a9dfb7f5671f38232db9a50606d07fe04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168e2fae5a34ddc5215c94d27893a7ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a168e2fae5a34ddc5215c94d27893a7ff">souffle::pathJoin</a> (const std::string &amp;first, const std::string &amp;second)</td></tr>
<tr class="memdesc:a168e2fae5a34ddc5215c94d27893a7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join two paths together; note that this does not resolve overlaps or relative paths.  <a href="namespacesouffle.html#a168e2fae5a34ddc5215c94d27893a7ff">More...</a><br /></td></tr>
<tr class="separator:a168e2fae5a34ddc5215c94d27893a7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">souffle::simpleName</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="mdescLeft">&#160;</td><td class="mdescRight">File name, with extension removed.  <a href="namespacesouffle.html#ab31e06999eb72da2f6d9a85bdd3dda59">More...</a><br /></td></tr>
<tr class="separator:ab31e06999eb72da2f6d9a85bdd3dda59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673608e9453179d30f6607384f54463a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">souffle::splitString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a6f94ddd542b6584a9155dca6dff07fdc">str</a>, char delimiter)</td></tr>
<tr class="memdesc:a673608e9453179d30f6607384f54463a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string given a delimiter.  <a href="namespacesouffle.html#a673608e9453179d30f6607384f54463a">More...</a><br /></td></tr>
<tr class="separator:a673608e9453179d30f6607384f54463a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f428910159c119c1dcdcab76ab7dfa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a06f428910159c119c1dcdcab76ab7dfa">souffle::stringify</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a06f428910159c119c1dcdcab76ab7dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stringify a string using escapes for newline, tab, double-quotes and semicolons.  <a href="namespacesouffle.html#a06f428910159c119c1dcdcab76ab7dfa">More...</a><br /></td></tr>
<tr class="separator:a06f428910159c119c1dcdcab76ab7dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2122cfa5acdee4846ecda0855f0beee4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">souffle::tempFile</a> ()</td></tr>
<tr class="memdesc:a2122cfa5acdee4846ecda0855f0beee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate temporary file.  <a href="namespacesouffle.html#a2122cfa5acdee4846ecda0855f0beee4">More...</a><br /></td></tr>
<tr class="separator:a2122cfa5acdee4846ecda0855f0beee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memTemplItemLeft" align="right" valign="top">detail::multiplying_printer&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">souffle::times</a> (const T &amp;value, unsigned num)</td></tr>
<tr class="memdesc:a0fff2be077dd5d1105f3a6e718339f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility printing a given value multiple times.  <a href="namespacesouffle.html#a0fff2be077dd5d1105f3a6e718339f2f">More...</a><br /></td></tr>
<tr class="separator:a0fff2be077dd5d1105f3a6e718339f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c409a13b5c317b5487c615a1f98d4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a47c409a13b5c317b5487c615a1f98d4c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; const T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a47c409a13b5c317b5487c615a1f98d4c">souffle::toConstPtrVector</a> (const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:a47c409a13b5c317b5487c615a1f98d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector of pointers.  <a href="namespacesouffle.html#a47c409a13b5c317b5487c615a1f98d4c">More...</a><br /></td></tr>
<tr class="separator:a47c409a13b5c317b5487c615a1f98d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157284692de2638d283c06b62135fe54"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a157284692de2638d283c06b62135fe54"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a157284692de2638d283c06b62135fe54">souffle::toPtrSet</a> (const std::set&lt; std::unique_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:a157284692de2638d283c06b62135fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a set of pointers.  <a href="namespacesouffle.html#a157284692de2638d283c06b62135fe54">More...</a><br /></td></tr>
<tr class="separator:a157284692de2638d283c06b62135fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9996cd50fb4bb795892186890469013b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9996cd50fb4bb795892186890469013b"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a9996cd50fb4bb795892186890469013b">souffle::toPtrSet</a> (const std::set&lt; std::shared_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:a9996cd50fb4bb795892186890469013b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a set of pointers.  <a href="namespacesouffle.html#a9996cd50fb4bb795892186890469013b">More...</a><br /></td></tr>
<tr class="separator:a9996cd50fb4bb795892186890469013b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62d4e824a9d74c7462da546a21780fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad62d4e824a9d74c7462da546a21780fe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe">souffle::toPtrVector</a> (const std::vector&lt; std::unique_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:ad62d4e824a9d74c7462da546a21780fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector of pointers.  <a href="namespacesouffle.html#ad62d4e824a9d74c7462da546a21780fe">More...</a><br /></td></tr>
<tr class="separator:ad62d4e824a9d74c7462da546a21780fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1e036ca35b6dceb0200ccbebc3dbf9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe1e036ca35b6dceb0200ccbebc3dbf9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#abe1e036ca35b6dceb0200ccbebc3dbf9">souffle::toPtrVector</a> (const std::vector&lt; std::shared_ptr&lt; T &gt;&gt; &amp;v)</td></tr>
<tr class="memdesc:abe1e036ca35b6dceb0200ccbebc3dbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector of pointers.  <a href="namespacesouffle.html#abe1e036ca35b6dceb0200ccbebc3dbf9">More...</a><br /></td></tr>
<tr class="separator:abe1e036ca35b6dceb0200ccbebc3dbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafad5f52d5175fff02862fa747763645"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafad5f52d5175fff02862fa747763645"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aafad5f52d5175fff02862fa747763645">souffle::toSet</a> ()</td></tr>
<tr class="memdesc:aafad5f52d5175fff02862fa747763645"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a set with a fixed set of elements within a single expression.  <a href="namespacesouffle.html#aafad5f52d5175fff02862fa747763645">More...</a><br /></td></tr>
<tr class="separator:aafad5f52d5175fff02862fa747763645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e7ecbc7d7a65ac2de10c9f21543f15"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... R&gt; </td></tr>
<tr class="memitem:aa3e7ecbc7d7a65ac2de10c9f21543f15"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa3e7ecbc7d7a65ac2de10c9f21543f15">souffle::toSet</a> (const T &amp;first, const R &amp;...rest)</td></tr>
<tr class="memdesc:aa3e7ecbc7d7a65ac2de10c9f21543f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a set with a fixed set of elements within a single expression.  <a href="namespacesouffle.html#aa3e7ecbc7d7a65ac2de10c9f21543f15">More...</a><br /></td></tr>
<tr class="separator:aa3e7ecbc7d7a65ac2de10c9f21543f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc08c83ad9634fc515b7aa094702949"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">souffle::toString</a> (const std::string &amp;<a class="el" href="json11_8h.html#a6f94ddd542b6584a9155dca6dff07fdc">str</a>)</td></tr>
<tr class="memdesc:aecc08c83ad9634fc515b7aa094702949"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function converting strings into strings (trivial case).  <a href="namespacesouffle.html#aecc08c83ad9634fc515b7aa094702949">More...</a><br /></td></tr>
<tr class="separator:aecc08c83ad9634fc515b7aa094702949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f01b6b803d03b90d7f33df9351ade"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac0f01b6b803d03b90d7f33df9351ade"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; detail::is_printable&lt; T &gt;::value, std::string &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aac0f01b6b803d03b90d7f33df9351ade">souffle::toString</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aac0f01b6b803d03b90d7f33df9351ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic function converting arbitrary objects to strings by utilizing their print capability.  <a href="namespacesouffle.html#aac0f01b6b803d03b90d7f33df9351ade">More...</a><br /></td></tr>
<tr class="separator:aac0f01b6b803d03b90d7f33df9351ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae87378d37c861ccf867805d6b6ed4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ae87378d37c861ccf867805d6b6ed4d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!detail::is_printable&lt; T &gt;::value, std::string &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6ae87378d37c861ccf867805d6b6ed4d">souffle::toString</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a6ae87378d37c861ccf867805d6b6ed4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fallback for the to-string function in case an unprintable object is supposed to be printed.  <a href="namespacesouffle.html#a6ae87378d37c861ccf867805d6b6ed4d">More...</a><br /></td></tr>
<tr class="separator:a6ae87378d37c861ccf867805d6b6ed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#ab2822ded4e7fd1466479b3fd6a1345a0">souffle::toVector</a> ()</td></tr>
<tr class="memdesc:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector with a fixed set of elements within a single expression.  <a href="namespacesouffle.html#ab2822ded4e7fd1466479b3fd6a1345a0">More...</a><br /></td></tr>
<tr class="separator:ab2822ded4e7fd1466479b3fd6a1345a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b505a63ac23af9d89fdcbbbba3ea8b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... R&gt; </td></tr>
<tr class="memitem:aa8b505a63ac23af9d89fdcbbbba3ea8b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#aa8b505a63ac23af9d89fdcbbbba3ea8b">souffle::toVector</a> (const T &amp;first, const R &amp;...rest)</td></tr>
<tr class="memdesc:aa8b505a63ac23af9d89fdcbbbba3ea8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function enabling the creation of a vector with a fixed set of elements within a single expression.  <a href="namespacesouffle.html#aa8b505a63ac23af9d89fdcbbbba3ea8b">More...</a><br /></td></tr>
<tr class="separator:aa8b505a63ac23af9d89fdcbbbba3ea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9757564e85959db8b14a9be7d544e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">souffle::which</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a6e9757564e85959db8b14a9be7d544e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple implementation of a which tool.  <a href="namespacesouffle.html#a6e9757564e85959db8b14a9be7d544e1">More...</a><br /></td></tr>
<tr class="separator:a6e9757564e85959db8b14a9be7d544e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a80fa0d26915405815f4a95751cafa736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define stord</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td>&#160;&#160;&#160;std::stoi(a)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string to a number. </p>

<p>Definition at line <a class="el" href="_util_8h_source.html#l00056">56</a> of file <a class="el" href="_util_8h_source.html">Util.h</a>.</p>

<p>Referenced by <a class="el" href="_r_a_m_i_8cpp_source.html#l00062">souffle::RAMI::evalExpr()</a>, and <a class="el" href="_l_v_m_8cpp_source.html#l00119">souffle::LVM::execute()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
